Classes let you package data and functions together in one unit.

:pause 3

Classes also allow you to inherit behaviour from other classes.

:pause 4

A simple class with no data or methods:

    >>> class A(object): pass

:pause 4

Let's make an instance:

    >>> a = A()

:pause 3

The instance has no attributes or methods because the class did not have any, but we can add some
attributes and use the instance simply to store data:

    >>> a.x = 1
    >>> a.y = "hi"
    >>> a.x; a.y
    1
    'hi'

:pause 6





Let's make a class representing a tree (the kind you see in a park):

    >>> class Tree(object):
            height = 0

:pause 4

    >>> birch = Tree()
    >>> birch.height
    0

:pause 4

Now I'd like to make a small function to make the tree grow one unit at a time:

    >>> def grow(tree):
            tree.height += 1

    >>> grow(birch); grow(birch)
    >>> birch.height
    2

:pause 4





That's really great.., but it would make even more sense if the tree class itself knew how to grow
itself. Certainly, a real tree does know how to grow!

:pause 4

In the grow() function, we were passing the tree instance as an argument. In the class, we want to
do the same, but I'm going to call it 'self' instead of 'tree' -- by Python convention, current
instance is always called 'self':

    >>> class Tree(object):
            height = 0

            def grow(self):
               self.height += 1

(I've inserted a blank line for readability but you'll need to omit it if typing into the
interpreter.)

:pause 6

Now we can tell the tree itself to grow:

    >>> birch = Tree()
    >>> birch.grow(); birch.height
    1
    >>> birch.grow(); birch.height
    2

:pause 4

It wasn't necessary to pass the instance as an argument because the class already handles that
automatically (the instance is passed as the first argument -- if you have additional arguments,
they have to be positioned after 'self').

:pause 5





You can add other trees and they all will have the same methods but will be independent instances
and will have their own sets of data:

    >>> bamboo = Tree()
    >>> bamboo.grow(); bamboo.height
    1
    >>> bamboo.grow(); bamboo.height
    2

:pause 4

Let's look at how to do class inheritance. The basic idea is that you can have related objects, in
other words, objects of the same "kind", like a regular tree and a flowering tree. Both trees have
heights and can grow, but a flowering tree can also, well, flower.

:pause 4

I already have a regular tree -- all I have to do is to inherit from it and add only the method
for flowering:

    >>> class FloweringTree(Tree):
            def flower(self):
                print("\/")

    >>> ft = FloweringTree()
    >>> ft.grow(); ft.height
    1

:pause 6





We have both the grow() method and height attribute because they're inherited from Tree!!

:pause 2

We can also use the newly defined flower() method:

    >>> ft.flower()
    \/

(This is supposed to be a picture of a flower..)

:pause 5

We could further inherit from FloweringTree class and have a new class that would share all of the
methods and attributes of both Tree and FloweringTree and have any number of new methods and
attributes.

:pause 4

There is a large number of special methods you can define in a class; one of the most often used
are __init__() and __str__() methods:

    >>> class Tree(object):
            def __init__(self, height=0):
                self.height = height

            def __str__(self):
                return "<Tree, height: %s>" % self.height

            def grow(self):
                self.height += 1


:pause 4

In this example, the init method accepts the initial height for the tree. The height value is
passed to the class when you create a new instance:

    >>> t = Tree(5)
    >>> t.height
    5

Our magical tree grows to 5 feet right after germinating! How can this be?!

:pause 4

One other common special method is __str__(), used when printing an object or otherwise using it
as a string:

    >>> t
    <Tree, height: 5>

:pause 4





Classes have many other special methods which can be used to make custom objects act like lists,
dictionaries, numbers, strings, et cetera.

Let's look at using special methods to create a limited list-like object:

    >>> class Forest(object):
            def __init__(self):
                self.trees = [Tree() for _ in range(5)]

            def __iter__(self):
                return iter(self.trees)

            def __getitem__(self, index):
                return self.trees[index]

:pause 8

(iter() function creates an iterator out of a sequence; __iter__() must always return an iterator;
I will cover iterators in more detail in a future tutorial.)

The iter method allows you to loop over items using 'for' operator; getitem method lets you get a
specific item from a list:


    >>> forest = Forest()
    >>> forest[2].grow()
    >>> forest[2]
    1

    >>> for tree in forest: print(tree)
    <Tree, height: 0>
    <Tree, height: 0>
    <Tree, height: 1>
    <Tree, height: 0>
    <Tree, height: 0>

:pause 2

As you can see, we can get the 3rd tree by using its index and we can loop over all of the trees.

:pause 2

Without the iter method, we wouldn't be able to see the trees for the forest!

NOTE: the forest object does NOT have full set of Python list functionality, but you can always
add a few other special methods to create a complete custom list; in many cases you don't need the
"full package" and Python allows you to add methods on a need-to-have basis.

:pause 5
